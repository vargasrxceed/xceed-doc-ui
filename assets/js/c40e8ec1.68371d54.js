"use strict";(self.webpackChunkxceed_doc_ui=self.webpackChunkxceed_doc_ui||[]).push([[3458],{7128:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>d,metadata:()=>l,toc:()=>u});var n=r(4848),i=r(8453),a=r(1470),o=r(9365);const d={},s="Data Virtualization",l={id:"datagrid/manipulating-data/providing-inserting-removing/02",title:"Data Virtualization",description:'The DataGridVirtualizingCollectionView class and its XAML proxy, the DataGridVirtualizingCollectionViewSource class, provide support for data virtualization. Also known as "virtual mode" or "lazy loading", data virtualization provides smart deferred querying of data, support for asynchronous data fetching, preemptive loading, and query abort notifications to ensure a smooth and seemless experience that leaves applications responsive and prevents needless queries to data servers.',source:"@site/docs/datagrid/manipulating-data/providing-inserting-removing/02.md",sourceDirName:"datagrid/manipulating-data/providing-inserting-removing",slug:"/datagrid/manipulating-data/providing-inserting-removing/02",permalink:"/xceed-doc-ui/docs/datagrid/manipulating-data/providing-inserting-removing/02",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Providing Data",permalink:"/xceed-doc-ui/docs/datagrid/manipulating-data/providing-inserting-removing/01"},next:{title:"Inserting Data",permalink:"/xceed-doc-ui/docs/datagrid/manipulating-data/providing-inserting-removing/03"}},c={},u=[{value:"Query Events",id:"query-events",level:2},{value:"Grouping",id:"grouping",level:2},{value:"Committing Modifications",id:"committing-modifications",level:2},{value:"Queryable Sources",id:"queryable-sources",level:2},{value:"Status Indicator Glyphs",id:"status-indicator-glyphs",level:2},{value:"Examples",id:"examples",level:2}];function h(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"data-virtualization",children:"Data Virtualization"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingCollectionView"})," class and its XAML proxy, the ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingCollectionViewSource"}),' class, provide support for data virtualization. Also known as "virtual mode" or "lazy loading", data virtualization provides smart deferred querying of data, support for asynchronous data fetching, preemptive loading, and query abort notifications to ensure a smooth and seemless experience that leaves applications responsive and prevents needless queries to data servers.']}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["The current implementations of the ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingCollectionView"})," and ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingCollectionViewSource"})," classes do not provide support for master/detail relationships or statistical functions."]})}),"\n",(0,n.jsx)(t.h2,{id:"query-events",children:"Query Events"}),"\n",(0,n.jsxs)(t.p,{children:['Data virtualization requires that certain "query" events be handled in order for prerequisite information and new items to be provided when necessary. Through the ',(0,n.jsx)(t.code,{children:"QueryItemCount"})," event, which is raised every time the grid is loaded or refreshed or its state changes (e.g., new sorting or filtering criteria are applied), the total number of records in the underlying data source must be provided, taking into account any filters that are currently applied to the items."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"QueryItems"})," event, which is raised whenever new records are required, allows the next batch of records to be fetched from the data source and provided to the grid. New items are provided to the grid by calling the ",(0,n.jsx)(t.code,{children:"EndQuery"})," method, which is exposed by the ",(0,n.jsx)(t.code,{children:"AsyncQueryInfo"})," instance received in the event arguments of the QueryItems event, with an array of items. The ",(0,n.jsx)(t.code,{children:"StartIndex"})," property of the ",(0,n.jsx)(t.code,{children:"AsyncQueryInfo"})," indicates the index in the data source at which to start retrieving the new items while its ",(0,n.jsx)(t.code,{children:"RequestedItemCount"})," property represents the number of new items that should be returned. The current state of the collection view (e.g., sorting and filtering) must ",(0,n.jsx)(t.strong,{children:"always"})," be taken into consideration when returning new items. If the ",(0,n.jsx)(t.code,{children:"EndQuery"})," method is called with an array that does not match the requested item count, the collection view will automatically refresh. If the array contains a ",(0,n.jsx)(t.strong,{children:"null"})," (",(0,n.jsx)(t.strong,{children:"Nothing"})," in Visual Basic) value, an exception will be thrown."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"EndQuery"})," method is considered thread-safe and can therefore be called from another thread in order to leave the main UI thread responsive when retrieving new items."]}),"\n",(0,n.jsxs)(t.p,{children:["Unlike the QueryItemCount and ",(0,n.jsx)(t.code,{children:"QueryItems"})," events, which must both be handled, the ",(0,n.jsx)(t.code,{children:"AbortQueryItems"})," event is not required; however, if handled, it will be raised when a QueryItems event has been raised for a page of data that is no longer needed and whose corresponding ",(0,n.jsx)(t.code,{children:"AsyncQueryInfo"})," object's ",(0,n.jsx)(t.code,{children:"EndQuery"})," method has not yet been called, allowing the pending operation to be canceled and preventing useless processing on the data server. If the ",(0,n.jsx)(t.code,{children:"AbortQueryItems"})," event is not handled, calls to the ",(0,n.jsx)(t.code,{children:"EndQuery"})," method for blocks of data that are no longer needed will be ignored."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"PageSize"})," property determines the number of items that are contained in each page of data that is loaded in memory (by default, 200) and also corresponds to the value of the ",(0,n.jsx)(t.code,{children:"RequestedItemCount"})," property exposed by the ",(0,n.jsx)(t.code,{children:"QueryItems"})," event's ",(0,n.jsx)(t.code,{children:"AsyncQueryInfo"})," object. The ",(0,n.jsx)(t.code,{children:"MaxRealizedItemCount"})," property represents the maximum amount of items that can be loaded into memory. When the limit determined by the ",(0,n.jsx)(t.code,{children:"MaxRealizedItemCount"})," property is reached and a new page of data is loaded, the oldest page will be released from memory."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"PreemptivePageQueryRatio"})," property corresponds to a value between 0.0 and 0.5 that represents the percentage from the start or the end of a a page that, when accessed, will cause the previous or next page to be queried and the items loaded in memory. By default, this property is set to 0.25 meaning that when an item is accessed and is part of the first 25% of a page, a ",(0,n.jsx)(t.code,{children:"QueryItems"})," event will be raised for the previous page of data. If the item is located in the last 25% of a page, a ",(0,n.jsx)(t.code,{children:"QueryItems"})," event will be raised to request the data for the next page. If the ",(0,n.jsx)(t.code,{children:"PreemptivePageQueryRatio"})," property is set to 0.5, the previous and next pages will always be fetched. If set to 0.0, this feature will be disabled and the ",(0,n.jsx)(t.code,{children:"QueryItems"})," event will only be raised when the requested item is not part of the in-memory page."]}),"\n",(0,n.jsx)(t.h2,{id:"grouping",children:"Grouping"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"QueryGroups"})," event is raised to allow the data items contained in a virtualized collection view to be grouped using the information provided by the QueryGroupsEventsArgs received in the event parameters."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"ChildGroupPropertyName"})," of the ",(0,n.jsx)(t.code,{children:"QueryGroupsEventArgs"})," represents the name of the item property that should be queried in order to find its distinct values and their count taking into account the parent groups, which can be retrieved through the GroupPath property. The ",(0,n.jsx)(t.code,{children:"GroupPath"})," property is a generic ",(0,n.jsx)(t.code,{children:"ReadOnlyCollection"})," of ",(0,n.jsx)(t.code,{children:"DataGridGroupInfo"})," objects, which each expose a property name and a value representing the parent group path. The order of the ",(0,n.jsx)(t.code,{children:"DataGridGroupInfo"})," objects in the collection corresponds to their order in the containing virtualized collection view and parent ",(0,n.jsx)(t.code,{children:"DataGridControl"}),". A ",(0,n.jsx)(t.code,{children:"DataGridGroupInfo"})," also exposes its matching group description."]}),"\n",(0,n.jsxs)(t.p,{children:["Once the distinct values for the queried item property have been retrieved, they must be added to the ",(0,n.jsx)(t.code,{children:"ChildGroupNameCountPairs"})," collection of the ",(0,n.jsx)(t.code,{children:"QueryGroupsEventArgs"})," received in the event parameters. The order in which the ",(0,n.jsx)(t.code,{children:"GroupNameCountPair"})," objects are added to the collection will correspond to their order in the virtualizing collection view and parent datagrid. The ChildSortDirection property can be consulted to know the order in which the ",(0,n.jsx)(t.code,{children:"GroupNameCountPair"})," objects should be added."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["To prevent groups from being created and therefore the ",(0,n.jsx)(t.code,{children:"QueryGroups"})," event from being raised, the ",(0,n.jsx)(t.code,{children:"MaxGroupLevels"})," property can be set to zero."]})}),"\n",(0,n.jsx)(t.h2,{id:"committing-modifications",children:"Committing Modifications"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"CommitItems"})," event is raised when a page of data that contains edited items is about to be released from memory. It is also called once for each page with modified data when the ",(0,n.jsx)(t.code,{children:"CommitAll"})," method of the ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingCollectionView"})," is called even if those pages are not being released from memory. By default, as previously mentioned, the ",(0,n.jsx)(t.code,{children:"CommitItems"})," event will be raised for each page that is about to be released from memory; however, by setting the CommitMode property to ",(0,n.jsx)(t.code,{children:"EditCommitted"}),", this behavior can be changed to raise the ",(0,n.jsx)(t.code,{children:"CommitItems"})," event for each item as soon as its edit process ends."]}),"\n",(0,n.jsxs)(t.p,{children:["The EndCommit method of the AsyncCommitInfo instance received in the event arguments of the ",(0,n.jsx)(t.code,{children:"CommitItems"})," event must be called when the synchronous or asynchronous update operation is completed. Until all pending commit operations are completed, the collection view will prevent the QueryItems events from being raised; therefore, it is essential that the ",(0,n.jsx)(t.code,{children:"EndCommit"})," method be called in order to continue fetching new items once edited items have been committed. It is recommended to call the ",(0,n.jsx)(t.code,{children:"CommitAll"})," method before the grid is unloaded so that any pending changes can be committed to the underlying data source."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"EndCommit"})," method is considered thread-safe and can therefore be called from another thread in order to leave the main UI thread responsive when committing modified items."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"CommitItems"})," event must be handled when dealing with an editable grid."]})}),"\n",(0,n.jsx)(t.h2,{id:"queryable-sources",children:"Queryable Sources"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingQueryableCollectionView"})," and the ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingQueryableCollectionViewSource"})," classes provide built in support for any data source that implements the ",(0,n.jsx)(t.code,{children:"IQueryable"})," or ",(0,n.jsx)(t.code,{children:"IQueryable<T>"})," interfaces (see Example 1)."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["The current implementations of the ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingQueryableCollectionView"})," and ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingQueryableCollectionViewSource"})," classes do not provide support for master/detail relationships or statistical functions."]})}),"\n",(0,n.jsx)(t.h2,{id:"status-indicator-glyphs",children:"Status Indicator Glyphs"}),"\n",(0,n.jsxs)(t.p,{children:["Three notification glyphs are provided that indicate the status of the underlying virtualized data connection (a ",(0,n.jsx)(t.code,{children:"DataGridVirtualizingCollectionView"})," or one of its derived classes). Specifically, these glyphs indicate when data is being loaded or committed, or when an error has occurred."]}),"\n",(0,n.jsxs)(t.p,{children:["Whether the glyphs are diplayed is controlled by the ",(0,n.jsx)(t.code,{children:"IsConnectionStateGlyphEnabled"})," property."]}),"\n",(0,n.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(t.p,{children:"Example 1: Binding to an IQueryable source"}),"\n",(0,n.jsx)(t.p,{children:"The following example demonstrates how to bind to a data source that implements IQueryable (LINQ DataContext) and allow items to be edited, deleted, inserted, and refreshed."}),"\n",(0,n.jsxs)(a.A,{children:[(0,n.jsx)(o.A,{value:"xml",label:"XAML",default:!0,children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n  <Grid.Resources>\r\n    <xcdg:DataGridVirtualizingQueryableCollectionViewSource x:Key="cvs_queryableSource"\r\n                                                            QueryableSource="{Binding Path=QueryableSource}"\r\n                                                            CommitMode="EditCommitted"\r\n                                                            CreatingNewItem="DataGridVirtualizingQueryableCollectionViewSource_CreatingNewItem"\r\n                                                            CommittingNewItem="DataGridVirtualizingQueryableCollectionViewSource_CommittingNewItem"\r\n                                                            CancelingNewItem="DataGridVirtualizingQueryableCollectionViewSource_CancelingNewItem"\r\n                                                            CommitItems="DataGridVirtualizingQueryableCollectionViewSource_CommitItems"\r\n                                                            RemovingItem="DataGridVirtualizingQueryableCollectionViewSource_RemovingItem" />\r\n  </Grid.Resources>\r\n  <xcdg:DataGridControl ItemsSource="{Binding Source={StaticResource cvs_queryableSource}}"\r\n                        ItemScrollingBehavior="Deferred"\r\n                        MaxGroupLevels="2"\r\n                        MaxSortLevels="2"\r\n                        IsDeleteCommandEnabled="True"\r\n                        IsRefreshCommandEnabled="True">\r\n      <xcdg:DataGridControl.Resources>\r\n        <Style TargetType="{x:Type xcdg:Row}"\r\n                x:Key="RowHeightStyle">\r\n            <Setter Property="Height"\r\n                    Value="27" />\r\n        </Style>\r\n        <Style TargetType="{x:Type xcdg:DataRow}"\r\n                BasedOn="{StaticResource RowHeightStyle}" />\r\n        <Style TargetType="{x:Type xcdg:InsertionRow}"\r\n                BasedOn="{StaticResource RowHeightStyle}" />\r\n      </xcdg:DataGridControl.Resources>\r\n      <xcdg:DataGridControl.View>\r\n        <xcdg:TableView>\r\n            <xcdg:TableView.FixedHeaders>\r\n              <DataTemplate>\r\n                  <xcdg:InsertionRow />\r\n              </DataTemplate>\r\n            </xcdg:TableView.FixedHeaders>\r\n        </xcdg:TableView>\r\n      </xcdg:DataGridControl.View>\r\n      <xcdg:DataGridControl.Columns>\r\n        <xcdg:Column FieldName="ProductID"\r\n                      AllowSort="False"\r\n                      AllowGroup="False" />\r\n      </xcdg:DataGridControl.Columns>\r\n  </xcdg:DataGridControl>\r\n</Grid>\n'})})}),(0,n.jsx)(o.A,{value:"csharp",label:"C#",children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:"public partial class Window1 : Window\r\n{\r\n  public Window1()\r\n  {\r\n    this.DataContext = this;\r\n    InitializeComponent();\r\n  }\r\n  // QUERYABLE SOURCE\r\n  public IQueryable QueryableSource\r\n  {\r\n    get\r\n    {\r\n      if( m_queryable == null )\r\n      {\r\n        m_northwind = new NorthwindDataContext();\r\n        m_queryable = m_northwind.Products;\r\n      }\r\n      return m_queryable;\r\n    }\r\n  }\r\n  private NorthwindDataContext m_northwind;\r\n  private IQueryable m_queryable;\r\n  // QUERYABLE INSERTION SUPPORT\r\n  private void DataGridVirtualizingQueryableCollectionViewSource_CreatingNewItem( object sender, DataGridCreatingNewItemEventArgs e )\r\n  {\r\n    Product productToInsert = new Product();\r\n    e.NewItem = productToInsert;\r\n    m_northwind.Products.InsertOnSubmit( productToInsert );\r\n    e.Handled = true;\r\n  }\r\n  private void DataGridVirtualizingQueryableCollectionViewSource_CommittingNewItem( object sender, DataGridCommittingNewItemEventArgs e )\r\n  {\r\n    try\r\n    {\r\n      m_northwind.SubmitChanges();\r\n    }\r\n    catch\r\n    {\r\n      e.Cancel = true;\r\n    }\r\n    e.Handled = true;\r\n  }\r\n  private void DataGridVirtualizingQueryableCollectionViewSource_CancelingNewItem( object sender, DataGridItemHandledEventArgs e )\r\n  {\r\n    m_northwind.GetChangeSet().Inserts.Clear();\r\n    e.Handled = true;\r\n  }\r\n  // QUERYABLE EDIT SUPPORT\r\n  private void DataGridVirtualizingQueryableCollectionViewSource_CommitItems( object sender, CommitItemsEventArgs e )\r\n  {\r\n    try\r\n    {\r\n      m_northwind.SubmitChanges();\r\n    }\r\n    catch\r\n    {\r\n      m_northwind.GetChangeSet().Updates.Clear();\r\n    }\r\n    finally\r\n    {\r\n      e.AsyncCommitInfo.EndCommit();\r\n    }\r\n  }\r\n  // QUERYABLE DELETE SUPPORT\r\n  private void DataGridVirtualizingQueryableCollectionViewSource_RemovingItem( object sender, DataGridRemovingItemEventArgs e )\r\n  {\r\n    try\r\n    {\r\n      m_northwind.Products.DeleteOnSubmit( e.Item as Product );\r\n      m_northwind.SubmitChanges();\r\n    }\r\n    catch\r\n    {\r\n      m_northwind.GetChangeSet().Deletes.Clear();\r\n      e.Cancel = true;\r\n    }\r\n    e.Handled = true;\r\n  }\r\n}\n"})})}),(0,n.jsx)(o.A,{value:"vbnet",label:"Visual Basic .NET",children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-vbnet",children:"Public Partial Class Window1\r\n               Inherits Window\r\n  Public Sub New\r\n    Me.DataContext = Me\r\n    InitializeComponent()\r\n  End Sub\r\n  ' QUERYABLE SOURCE\r\n  Public ReadOnly Property QueryableSource As IQueryable\r\n    Get\r\n      If m_queryable Is Nothing Then\r\n        m_northwind = New NorthwindDataContext()\r\n        m_queryable = m_northwind.Products\r\n      End If\r\n      Return m_queryable\r\n    End Get\r\n  End Property\r\n  Private m_northwind As NorthwindDataContext\r\n  Private m_queryable As IQueryable\r\n  ' QUERYABLE INSERTION SUPPORT\r\n  Private Sub DataGridVirtualizingQueryableCollectionViewSource_CreatingNewItem( sender As Object, e As DataGridCreatingNewItemEventArgs )\r\n    Dim productToInsert As New Product()\r\n    e.NewItem = productToInsert\r\n    m_northwind.Products.InsertOnSubmit( productToInsert )\r\n    e.Handled = True\r\n  End Sub\r\n  Private Sub DataGridVirtualizingQueryableCollectionViewSource_CommittingNewItem( sender As Object, e As DataGridCommittingNewItemEventArgs )\r\n    Try\r\n      m_northwind.SubmitChanges()\r\n    Catch e As Exception\r\n      e.Cancel = True\r\n    End try\r\n    e.Handled = True\r\n  End Sub\r\n  Private Sub DataGridVirtualizingQueryableCollectionViewSource_CancelingNewItem( sender As Object, e As DataGridItemHandledEventArgs )\r\n    m_northwind.GetChangeSet().Inserts.Clear()\r\n    e.Handled = True\r\n  End Sub\r\n  ' QUERYABLE EDIT SUPPORT\r\n  Private Sub DataGridVirtualizingQueryableCollectionViewSource_CommitItems( sender As Object, e As CommitItemsEventArgs )\r\n    Try\r\n      m_northwind.SubmitChanges()\r\n    Catch e As Exception\r\n      m_northwind.GetChangeSet().Updates.Clear()\r\n    Finally\r\n      e.AsyncCommitInfo.EndCommit()\r\n    End Try\r\n  End Sub\r\n  ' QUERYABLE DELETE SUPPORT\r\n  Private Sub DataGridVirtualizingQueryableCollectionViewSource_RemovingItem( sender As Object, e as DataGridRemovingItemEventArgs )\r\n    Try\r\n      m_northwind.Products.DeleteOnSubmit( TryCast( e.Item, Product ) )\r\n      m_northwind.SubmitChanges()\r\n    Catch e As Exception\r\n      m_northwind.GetChangeSet().Deletes.Clear()\r\n      e.Cancel = True\r\n    End Try\r\n    e.Handled = True\r\n  End Sub\r\nEnd Class\n"})})})]})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},9365:(e,t,r)=>{r.d(t,{A:()=>o});r(6540);var n=r(4164);const i={tabItem:"tabItem_Ymn6"};var a=r(4848);function o(e){let{children:t,hidden:r,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,n.A)(i.tabItem,o),hidden:r,children:t})}},1470:(e,t,r)=>{r.d(t,{A:()=>C});var n=r(6540),i=r(4164),a=r(3104),o=r(6347),d=r(205),s=r(7485),l=r(1682),c=r(679);function u(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:r}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:r,attributes:n,default:i}}=e;return{value:t,label:r,attributes:n,default:i}}))}(r);return function(e){const t=(0,l.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function m(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:r}=e;const i=(0,o.W6)(),a=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,s.aZ)(a),(0,n.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(i.location.search);t.set(a,e),i.replace({...i.location,search:t.toString()})}),[a,i])]}function g(e){const{defaultValue:t,queryString:r=!1,groupId:i}=e,a=h(e),[o,s]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=r.find((e=>e.default))??r[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:a}))),[l,u]=p({queryString:r,groupId:i}),[g,b]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,a]=(0,c.Dv)(r);return[i,(0,n.useCallback)((e=>{r&&a.set(e)}),[r,a])]}({groupId:i}),v=(()=>{const e=l??g;return m({value:e,tabValues:a})?e:null})();(0,d.A)((()=>{v&&s(v)}),[v]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),b(e)}),[u,b,a]),tabValues:a}}var b=r(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=r(4848);function x(e){let{className:t,block:r,selectedValue:n,selectValue:o,tabValues:d}=e;const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),c=e=>{const t=e.currentTarget,r=s.indexOf(t),i=d[r].value;i!==n&&(l(t),o(i))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const r=s.indexOf(e.currentTarget)+1;t=s[r]??s[0];break}case"ArrowLeft":{const r=s.indexOf(e.currentTarget)-1;t=s[r]??s[s.length-1];break}}t?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":r},t),children:d.map((e=>{let{value:t,label:r,attributes:a}=e;return(0,y.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>s.push(e),onKeyDown:u,onClick:c,...a,className:(0,i.A)("tabs__item",v.tabItem,a?.className,{"tabs__item--active":n===t}),children:r??t},t)}))})}function f(e){let{lazy:t,children:r,selectedValue:a}=e;const o=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function w(e){const t=g(e);return(0,y.jsxs)("div",{className:(0,i.A)("tabs-container",v.tabList),children:[(0,y.jsx)(x,{...t,...e}),(0,y.jsx)(f,{...t,...e})]})}function C(e){const t=(0,b.A)();return(0,y.jsx)(w,{...e,children:u(e.children)},String(t))}},8453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>d});var n=r(6540);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);