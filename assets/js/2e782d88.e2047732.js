"use strict";(self.webpackChunkxceed_doc_ui=self.webpackChunkxceed_doc_ui||[]).push([[9115],{24:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>f,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var r=n(4848),i=n(8453),o=n(1470),a=n(9365);const s={},c="Creating Statistical Functions",l={id:"fundamentals/statical-functions/creating-statistical-functions",title:"Creating Statistical Functions",description:"When creating a custom statistical function, it is important to analyze how the result is to be calculated in order to achieve the best possible performance. For a given set of data, if a statistical function result can be calculated from the result of the subsets of data forming all the data, the function can derive from CumulativeStatFunction and take advantage of the performance enhancements it offers. If the results cannot be calculated from a subset of data, then you can derive directly from StatFunction.",source:"@site/datagrid/fundamentals/statical-functions/creating-statistical-functions.md",sourceDirName:"fundamentals/statical-functions",slug:"/fundamentals/statical-functions/creating-statistical-functions",permalink:"/xceed-doc-ui/datagrid/fundamentals/statical-functions/creating-statistical-functions",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebardatagrid",previous:{title:"Statistical Functions",permalink:"/xceed-doc-ui/datagrid/fundamentals/statical-functions/overview"},next:{title:"Views and Themes",permalink:"/xceed-doc-ui/datagrid/fundamentals/views-themes/overview"}},u={},d=[{value:"Accumulating Values",id:"accumulating-values",level:2},{value:"Initializing and Identifying a Statistical Function",id:"initializing-and-identifying-a-statistical-function",level:2},{value:"Getting Results",id:"getting-results",level:2},{value:"Examples",id:"examples",level:2}];function h(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"creating-statistical-functions",children:"Creating Statistical Functions"})}),"\n",(0,r.jsxs)(t.p,{children:["When creating a custom statistical function, it is important to analyze how the result is to be calculated in order to achieve the best possible performance. For a given set of data, if a statistical function result can be calculated from the result of the subsets of data forming all the data, the function can derive from ",(0,r.jsx)(t.code,{children:"CumulativeStatFunction"})," and take advantage of the performance enhancements it offers. If the results cannot be calculated from a subset of data, then you can derive directly from ",(0,r.jsx)(t.code,{children:"StatFunction"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"accumulating-values",children:"Accumulating Values"}),"\n",(0,r.jsxs)(t.p,{children:["A statistical function's Accumulate method is called\u2014as many times as necessary\u2014to accumulate the values required to calculate its result. The ",(0,r.jsx)(t.code,{children:"AccumulateChildResult"})," method, rather than the Accumulate method, will be called if the statistical function requires the result of a child group in order to calculate its own result (i.e., derives from CumulativeStatFunction). If it is not possible to accumulate child results (e.g., the statistical function is accumulating values on a last level group), the Accumulate method will be called instead for every data item in the group."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"PrerequisiteFunctions"})," property contains a list of statistical functions whose results may be required by the current function in order to calculate its own result. When a prerequisite function is present, the internal engine will search for an equivalent statistical function (see GetEquivalenceKey and IsEquivalent methods) that has the same SourcePropertyName and will use the result of that function if one is found. If there are no statistical functions that have the same SourcePropertyName, it will calculate it and add it to the pool of results for a future use, if need be. In other words, a prerequisite function defines a prerequisite of nature, not of instance. Using prerequisites may improve performance in certain situations."]}),"\n",(0,r.jsxs)(t.p,{children:["When creating a statistical function that does not need child results (i.e., derives directly from StatFunction), its ",(0,r.jsx)(t.code,{children:"RequiresAccumulation"})," property should be set to true (default) to indicate that it will accumulate its own result. By setting this property to true, the Accumulate or ",(0,r.jsx)(t.code,{children:"AccumulateChildResult"})," methods will be called\u2014as many times as necessary\u2014to accumulate the values required to calculate the result of the statistical function. If the ",(0,r.jsx)(t.code,{children:"RequiresAccumulation"})," property is set to false, neither method will be called and only the results of the function's prerequisite functions will be used; setting ",(0,r.jsx)(t.code,{children:"RequiresAccumulation"})," to false will also improve performance."]}),"\n",(0,r.jsx)(t.p,{children:"Custom statistical functions should call the CheckSealed method before attempting to apply changes that can affect the state of a statistical function. Any public property that is added to a statistical function whose value can affect the result should check to see if the function is sealed before attempting to set the new value. Temporary values accumulated in the statistical function do not need to do this verification."}),"\n",(0,r.jsx)(t.h2,{id:"initializing-and-identifying-a-statistical-function",children:"Initializing and Identifying a Statistical Function"}),"\n",(0,r.jsx)(t.p,{children:"The Initialize method specifies the type in which the values of a statistical function will be accumulated (i.e., the data types corresponding to the SourcePropertyName, in the same order). Typically, Initialize is overridden when the accumulation data type needs to be known in advance rather than verifying it every time Accumulate is called. The InitializeFromInstance method initializes the properties of the current instance of the same-type statistical function when a new instance of the same function needs to be created and should be overridden only if a property that affects the end result is added, in order to include the new property in the initializing process (e.g., the IncludeNullValues property of the CountFunction class). When overriding PrerequisiteFunctions in a derived class, the InitializePrerequisites method must also be overridden to retrieve the results of the prerequisite statistical functions."}),"\n",(0,r.jsx)(t.p,{children:'Each statistical function is required to provide a unique equivalence key that will return the same value for two statistical functions that would theoretically return the same result for the same values. The "key" is provided through the GetEquivalenceKey method while the IsEquivalent method can be called to verify if the current instance is equivalent to another. Together, these methods can be thought of as the equivalent of the Equals and GetHashCode methods.'}),"\n",(0,r.jsxs)(t.admonition,{type:"note",children:[(0,r.jsx)(t.p,{children:"The IsEquivalent method should be overridden only if a property that affects the end result is added. In this case, GetEquivalenceKey should also be overridden to return a new key.\r\n::"}),(0,r.jsx)(t.h2,{id:"getting-results",children:"Getting Results"}),(0,r.jsx)(t.p,{children:"The GetResult method retrieves the result of the statistical function while the Validate method ensures that the function is able to calculate the result by verify that all the required properties have been set and that they contain valid values. If an exception occurs in the Accumulate, AccumulateChildResult, or GetResult methods, it will be caught by a grid and returned as the result of the statistical function. In some cases, such as when the statistical function's required parameters are being validated in the Validate method, the exception will not be caught since if the validation fails the statistical function is not able to calculate its result."}),(0,r.jsx)(t.p,{children:"The Reset method resets the statistical function to its original state and will be called every time the result needs to be recalculated."}),(0,r.jsx)(t.h2,{id:"examples",children:"Examples"}),(0,r.jsx)(t.p,{children:"All examples in this topic assume that the grid is bound to the Products table of the Northwind database, unless stated otherwise."}),(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Custom statistical function"}),(0,r.jsxs)(t.p,{children:["The following example demonstrates how to create a custom statistical function based on the ",(0,r.jsx)(t.code,{children:"CountFunction"}),", which will only count the items if they match the specified conditions."]}),(0,r.jsxs)(o.A,{children:[(0,r.jsx)(a.A,{value:"xaml",label:"XAML",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid"\r\n        xmlns:local="clr-namespace:Xceed.Wpf.Documentation"\r\n        xmlns:s="clr-namespace:System;assembly=mscorlib">\r\n    <Grid.Resources>\r\n      <xcdg:DataGridCollectionViewSource x:Key="cvs_products"\r\n                                          Source="{Binding Source={x:Static Application.Current}, Path=Products}">\r\n          <xcdg:DataGridCollectionViewSource.StatFunctions>\r\n            <local:CountIfFunction ResultPropertyName="CountProductsToOrder"\r\n                                  SourcePropertyName="ReorderLevel,UnitsOnOrder">\r\n              \x3c!-- Only count products which have a ReorderLevel of 5, 10, 15, or 20, and\r\n                    a UnitsOnOrder value of 0. --\x3e\r\n              <local:CountIfFunction.Conditions>\r\n                  <s:String>^5$|^10$|^15$|^20$</s:String>\r\n                  <s:String>^0$</s:String>\r\n              </local:CountIfFunction.Conditions>\r\n            </local:CountIfFunction>\r\n          </xcdg:DataGridCollectionViewSource.StatFunctions>\r\n          <xcdg:DataGridCollectionViewSource.GroupDescriptions>\r\n            <xcdg:DataGridGroupDescription PropertyName="CategoryID" />\r\n          </xcdg:DataGridCollectionViewSource.GroupDescriptions>\r\n      </xcdg:DataGridCollectionViewSource>\r\n    </Grid.Resources>\r\n    <xcdg:DataGridControl x:Name="OrdersGrid"\r\n                          ItemsSource="{Binding Source={StaticResource cvs_products}}">\r\n      <xcdg:DataGridControl.Columns>\r\n          <xcdg:Column FieldName="ReorderLevel"/>\r\n      </xcdg:DataGridControl.Columns>\r\n      <xcdg:DataGridControl.DefaultGroupConfiguration>\r\n          <xcdg:GroupConfiguration>\r\n            <xcdg:GroupConfiguration.Footers>\r\n                <DataTemplate>\r\n                  <xcdg:StatRow Background="Pink">\r\n                    <xcdg:StatCell FieldName="ReorderLevel"\r\n                                    ResultPropertyName="CountProductsToOrder" />                      \r\n                  </xcdg:StatRow>  \r\n              </DataTemplate>\r\n            </xcdg:GroupConfiguration.Footers>\r\n          </xcdg:GroupConfiguration>\r\n      </xcdg:DataGridControl.DefaultGroupConfiguration>\r\n    </xcdg:DataGridControl>\r\n  </Grid>\n'})})}),(0,r.jsx)(a.A,{value:"csharp",label:"C#",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"  using System;\r\n  using Xceed.Wpf.DataGrid.Stats;\r\n  using System.Text.RegularExpressions;\r\n  using System.Collections.ObjectModel;\r\n  using System.Collections.Specialized;\r\n  namespace Xceed.Wpf.Documentation\r\n  {\r\n    // This statistical function derives from CumulativeStatFunction because it can\r\n    // accumulate \"partial\" results. For instance, results of sub-group. This allows\r\n    // for better performance.\r\n    public class CountIfFunction : CumulativeStatFunction\r\n    {\r\n      // A parameterless constructor is necessary to use the class in XAML.\r\n      public CountIfFunction()\r\n        : base()\r\n      {\r\n        m_conditions = new ObservableCollection<string>();\r\n        m_conditions.CollectionChanged += new System.Collections.Specialized.NotifyCollectionChangedEventHandler( m_conditions_CollectionChanged );\r\n      }\r\n      // Initialize a new instance of the CountIfFunction specifying the ResultPropertyName\r\n      // and the SourcePropertyName.\r\n      public CountIfFunction( string resultPropertyName, string sourcePropertyNames )\r\n        : base( resultPropertyName, sourcePropertyNames )\r\n      {\r\n        m_conditions = new ObservableCollection<string>();\r\n        m_conditions.CollectionChanged += new System.Collections.Specialized.NotifyCollectionChangedEventHandler( m_conditions_CollectionChanged );\r\n      }\r\n      // Each condition applies to the values of the corresponding source property name\r\n      // (e.g., the first condition applies to the values of the first source property name).\r\n      // Gets the conditions that will be applied to the various values.\r\n      public ObservableCollection<string> Conditions\r\n      {\r\n        get\r\n        {\r\n          return m_conditions;\r\n        }\r\n      }\r\n      // When the grid needs to create temporary CountIfFunction instances for its\r\n      // calculation, this method will be called. Be sure to initialize everything\r\n      // having an impact on the result here.\r\n      protected override void InitializeFromInstance( StatFunction source )\r\n      {\r\n        base.InitializeFromInstance( source );\r\n        foreach( string condition in ( ( CountIfFunction )source ).Conditions )\r\n          this.Conditions.Add( condition );\r\n      }\r\n      // Validate the CountIf statistical function to make sure that it is capable\r\n      // to calculate its result. In our case, we need to make sure that a ResultPropertyName\r\n      // has been specified and that we have the same number of source property names\r\n      // as conditions.\r\n      protected override void Validate()\r\n      {\r\n        if( ( string.IsNullOrEmpty( ResultPropertyName ) ) ||\r\n            ( m_conditions.Count != this.SourcePropertyName.Split( ',' ).Length ) )\r\n        {\r\n          throw new InvalidOperationException();\r\n        }\r\n      }\r\n      // This method will be called when a new calculation is about to begin.\r\n      protected override void Reset()\r\n      {\r\n        m_count = 0;\r\n      }\r\n      // This method will be called for each data item that is part of the set (a group or\r\n      // the grid).\r\n      protected override void Accumulate( object[] values )\r\n      {\r\n        for( int i = 0; i < m_conditions.Count; i++ )\r\n        {\r\n          // As soon as one condition does not match is associated value, we simply\r\n          // return without having done the accumulation (the count increment).\r\n          if( !Regex.IsMatch( values[ i ].ToString(), m_conditions[ i ] ) )\r\n            return;\r\n        }\r\n        // In case of an overflow, we want to stop the calculation and report the error.\r\n        checked\r\n        {\r\n          m_count++;\r\n        }\r\n      }\r\n      // This method will be called when calculating the result of a group having\r\n      // sub-groups. Obviously, it will be called once for each sub-group.\r\n      protected override void AccumulateChildResult( StatResult childResult )\r\n      {\r\n        checked\r\n        {\r\n          m_count += Convert.ToInt64( childResult.Value );\r\n        }\r\n      }\r\n      // This method should return the result calculated so far.\r\n      protected override StatResult GetResult()\r\n      {\r\n        return new StatResult( m_count );\r\n      }\r\n      // The addition of the Conditions property, which influences the result of the\r\n      // statistical function, the CountIf function requires us to override IsEquivalent\r\n      // and GetEquivalenceKey to return a new key when 2 instances are compared.\r\n      protected override bool IsEquivalent( StatFunction statFunction )\r\n      {\r\n        CountIfFunction countIfFunction = statFunction as CountIfFunction;\r\n        if( countIfFunction == null )\r\n          return false;\r\n        if( m_conditions.Count != countIfFunction.Conditions.Count )\r\n          return false;\r\n        for( int i = 0; i < m_conditions.Count; i++ )\r\n        {\r\n          if( m_conditions[ i ] != countIfFunction.Conditions[ i ] )\r\n            return false;\r\n        }\r\n        return base.IsEquivalent( statFunction );\r\n      }\r\n      protected override int GetEquivalenceKey()\r\n      {\r\n        int hashCode = base.GetEquivalenceKey();\r\n        for( int i = 0; i < m_conditions.Count; i++ )\r\n          hashCode ^= m_conditions[ i ].GetHashCode();\r\n        return hashCode;\r\n      }\r\n      // Do not allow the Conditions property to be changed if the statistical function has\r\n      // been sealed (i.e., assigned to the DataGridCollectionView.StatFunctions property).\r\n      private void m_conditions_CollectionChanged( object sender, NotifyCollectionChangedEventArgs e )\r\n      {\r\n        this.CheckSealed();\r\n      }\r\n      private ObservableCollection<string> m_conditions;\r\n      private long m_count;\r\n    }\r\n  }\n"})})}),(0,r.jsx)(a.A,{value:"vbnet",label:"VB.NET",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-vbnet",children:"  Imports System\r\n  Imports System.Collections.ObjectModel\r\n  Imports System.Collections.Specialized\r\n  Imports System.Text.RegularExpressions\r\n  Imports Xceed.Wpf.DataGrid.Stats\r\n  Namespace Xceed.Wpf.Documentation\r\n    ' This statistical function derives from CumulativeStatFunction because it can\r\n    ' accumulate \"partial\" results. For instance, results of sub-group. This allows\r\n    ' for better performance.\r\n    Public Class CountIfFunction\r\n      Inherits CumulativeStatFunction\r\n      ' A parameterless constructor is necessary to use the class in XAML.\r\n      Public Sub New()\r\n        MyBase.New()\r\n        m_conditions = New ObservableCollection(Of String)()\r\n        AddHandler m_conditions.CollectionChanged, AddressOf m_conditions_CollectionChanged\r\n      End Sub\r\n      ' Initialize a new instance of the CountIfFunction specifying the ResultPropertyName\r\n      ' and the SourcePropertyName.\r\n      Public Sub New(ByVal resultPropertyName As String, ByVal sourcePropertyNames As String)\r\n        MyBase.New(resultPropertyName, sourcePropertyNames)\r\n        m_conditions = New ObservableCollection(Of String)()\r\n        AddHandler m_conditions.CollectionChanged, AddressOf m_conditions_CollectionChanged\r\n      End Sub\r\n      ' Each condition applies to the values of the corresponding source property name\r\n      ' (e.g., the first condition applies to the values of the first source property name).\r\n      ' Gets the conditions that will be applied to the various values.\r\n      Public ReadOnly Property Conditions() As ObservableCollection(Of String)\r\n        Get\r\n          Return m_conditions\r\n        End Get\r\n      End Property\r\n      ' When the grid needs to create temporary CountIfFunction instances for its\r\n      ' calculation, this method will be called. Be sure to initialize everything\r\n      ' having an impact on the result here.\r\n      Protected Overrides Sub InitializeFromInstance(ByVal source As StatFunction)\r\n        MyBase.InitializeFromInstance(source)\r\n        For Each condition As String In (CType(source, CountIfFunction)).Conditions\r\n          Me.Conditions.Add(condition)\r\n        Next condition\r\n      End Sub\r\n      ' Validate the CountIf statistical function to make sure that it is capable\r\n      ' to calculate its result. In our case, we need to make sure that a ResultPropertyName\r\n      ' has been specified and that we have the same number of source property names\r\n      ' as conditions.\r\n      Protected Overrides Sub Validate()\r\n        If (Me.ResultPropertyName Is Nothing) OrElse\r\n          (Me.ResultPropertyName = String.Empty) OrElse\r\n          (m_conditions.Count <> Me.SourcePropertyName.Split(\",\"c).Length) Then\r\n          Throw New InvalidOperationException()\r\n        End If\r\n      End Sub\r\n      ' This method will be called when a new calculation is about to begin.\r\n      Protected Overrides Sub Reset()\r\n        m_count = 0\r\n      End Sub\r\n      ' This method will be called for each data item that is part of the set (a group or\r\n      ' the grid).\r\n      Protected Overrides Sub Accumulate(ByVal values As Object())\r\n        Dim i As Integer = 0\r\n        Do While i < m_conditions.Count\r\n          ' As soon as one condition does not match is associated value, we simply\r\n          ' return without having done the accumulation (the count increment).\r\n          If (Not Regex.IsMatch(values(i).ToString(), m_conditions(i))) Then\r\n            Return\r\n          End If\r\n          i += 1\r\n        Loop\r\n        ' The compilation configuration will cause this line to throw\r\n        ' if an OverflowException occurs.\r\n        m_count += 1\r\n      End Sub\r\n      ' This method will be called when calculating the result of a group having\r\n      ' sub-groups. Obviously, it will be called once for each sub-group.\r\n      Protected Overrides Sub AccumulateChildResult(ByVal childResult As StatResult)\r\n        m_count += Convert.ToInt64(childResult.Value)\r\n      End Sub\r\n      ' This method should return the result calculated so far.\r\n      Protected Overrides Function GetResult() As StatResult\r\n        Return New StatResult(m_count)\r\n      End Function\r\n      ' The addition of the Conditions property, which influences the result of the\r\n      ' statistical function, the CountIf function requires us to override IsEquivalent\r\n      ' and GetEquivalenceKey to return a new key when 2 instances are compared.\r\n      Protected Overrides Function IsEquivalent(ByVal statFunction As StatFunction) As Boolean\r\n        Dim countIfFunction As CountIfFunction = TryCast(statFunction, CountIfFunction)\r\n        If countIfFunction Is Nothing Then\r\n          Return False\r\n        End If\r\n        If m_conditions.Count <> countIfFunction.Conditions.Count Then\r\n          Return False\r\n        End If\r\n        Dim i As Integer = 0\r\n        Do While i < m_conditions.Count\r\n          If m_conditions(i) <> countIfFunction.Conditions(i) Then\r\n            Return False\r\n          End If\r\n          i += 1\r\n        Loop\r\n        Return MyBase.IsEquivalent(statFunction)\r\n      End Function\r\n      Protected Overrides Function GetEquivalenceKey() As Integer\r\n        Dim hashCode As Integer = MyBase.GetEquivalenceKey()\r\n        Dim i As Integer = 0\r\n        Do While i < m_conditions.Count\r\n          hashCode = hashCode Xor m_conditions(i).GetHashCode()\r\n          i += 1\r\n        Loop\r\n        Return hashCode\r\n      End Function\r\n      ' Do not allow the Conditions property to be changed if the statistical function has\r\n      ' been sealed (i.e, assigned to the DataGridCollectionView.StatFunctions property).\r\n      Private Sub m_conditions_CollectionChanged(ByVal sender As Object, ByVal e As NotifyCollectionChangedEventArgs)\r\n        Me.CheckSealed()\r\n      End Sub\r\n      Private m_conditions As ObservableCollection(Of String)\r\n      Private m_count As Long\r\n    End Class\r\n  End Namespace\n"})})})]})]})]})]})}function f(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>a});n(6540);var r=n(4164);const i={tabItem:"tabItem_Ymn6"};var o=n(4848);function a(e){let{children:t,hidden:n,className:a}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,a),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>I});var r=n(6540),i=n(4164),o=n(3104),a=n(6347),s=n(205),c=n(7485),l=n(1682),u=n(679);function d(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:i}}=e;return{value:t,label:n,attributes:r,default:i}}))}(n);return function(e){const t=(0,l.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function f(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const i=(0,a.W6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,c.aZ)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(i.location.search);t.set(o,e),i.replace({...i.location,search:t.toString()})}),[o,i])]}function p(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,o=h(e),[a,c]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!f({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[l,d]=m({queryString:n,groupId:i}),[p,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,o]=(0,u.Dv)(n);return[i,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:i}),v=(()=>{const e=l??p;return f({value:e,tabValues:o})?e:null})();(0,s.A)((()=>{v&&c(v)}),[v]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!f({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),g(e)}),[d,g,o]),tabValues:o}}var g=n(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(4848);function y(e){let{className:t,block:n,selectedValue:r,selectValue:a,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),u=e=>{const t=e.currentTarget,n=c.indexOf(t),i=s[n].value;i!==r&&(l(t),a(i))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},t),children:s.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>c.push(e),onKeyDown:d,onClick:u,...o,className:(0,i.A)("tabs__item",v.tabItem,o?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function C(e){let{lazy:t,children:n,selectedValue:o}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===o));return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==o})))})}function w(e){const t=p(e);return(0,b.jsxs)("div",{className:(0,i.A)("tabs-container",v.tabList),children:[(0,b.jsx)(y,{...t,...e}),(0,b.jsx)(C,{...t,...e})]})}function I(e){const t=(0,g.A)();return(0,b.jsx)(w,{...e,children:d(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var r=n(6540);const i={},o=r.createContext(i);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);