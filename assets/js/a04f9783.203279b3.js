"use strict";(self.webpackChunkxceed_doc_ui=self.webpackChunkxceed_doc_ui||[]).push([[1237],{968:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var r=n(4848),i=n(8453);const l={},o="Part 4: Templating",a={id:"creating-custom-theme/04",title:"Part 4: Templating",description:"If you're like me, you find templates to be a little daunting at times. Luckily, all the templates you will need are included (not in the custom-theme project, but we'll get to that) and are just waiting to be pasted into the new theme.",source:"@site/datagrid/creating-custom-theme/04.md",sourceDirName:"creating-custom-theme",slug:"/creating-custom-theme/04",permalink:"/xceed-doc-ui/datagrid/creating-custom-theme/04",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebardatagrid",previous:{title:"Part 3: Styling",permalink:"/xceed-doc-ui/datagrid/creating-custom-theme/03"},next:{title:"Part 5: Using Your Custom Theme",permalink:"/xceed-doc-ui/datagrid/creating-custom-theme/05"}},s={},d=[{value:"Retrieving the Templates",id:"retrieving-the-templates",level:2},{value:"Templating Elements",id:"templating-elements",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"part-4-templating",children:"Part 4: Templating"})}),"\n",(0,r.jsx)(t.p,{children:"If you're like me, you find templates to be a little daunting at times. Luckily, all the templates you will need are included (not in the custom-theme project, but we'll get to that) and are just waiting to be pasted into the new theme."}),"\n",(0,r.jsxs)(t.p,{children:['It helps to think of the templates that we will be adding as "overrides" since the new templates that we will be adding have the same names as the default templates in the base-xaml file. The base-xaml file, which contains the default templates, is located in the common-theme folder located under the Xceed DataGrid for WPF installation folder in the Themes\\Common folder. Each view has its own base file, which contains the element templates for the specific view. Since we are only dealing with the ',(0,r.jsx)(t.strong,{children:"TableView"}),", you only need to open the ",(0,r.jsx)(t.strong,{children:"TableView"}),".GridElementTemplates.xaml file. Remember in the ",(0,r.jsx)(t.a,{href:"03",children:"Styles part"})," when I talked about one XAML file being included in the resources of another? Well the ",(0,r.jsx)(t.strong,{children:"TableView.GridElementTemplates.xaml"})," file is included in the resources of the ",(0,r.jsx)(t.strong,{children:"TableView.Office2007Tutorial.xaml"})," file."]}),"\n",(0,r.jsxs)(t.p,{children:['All the templates that will be overridden need (OK, not really "need", but it is the suggested place) to be placed in the "Templates specific to this View/Theme/ColorScheme" section of the ',(0,r.jsx)(t.strong,{children:"TableView.Office2007Tutorial.xaml"})," file."]}),"\n",(0,r.jsxs)(t.p,{children:["The list of elements to template was provided in ",(0,r.jsx)(t.a,{href:"02",children:"part 2"}),", but for simplicity's sake, it has been copied over to this part as well (see Table 1). Each template will be included for those of you who prefer to just cut-and-paste code."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Table 1"}),": Elements to template"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Element to template"}),(0,r.jsx)(t.th,{children:"What we will be changing"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"RowSelector"}),(0,r.jsx)(t.td,{children:"Custom separator lines and change the background when the mouse is pressed"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ColumnManagerCell"}),(0,r.jsx)(t.td,{children:"Change the background when the mouse is pressed Custom separator lines Change the color of the sort glyph"})]})]})]}),"\n",(0,r.jsx)(t.p,{children:"So, without further ado, let's modify some templates."}),"\n",(0,r.jsx)(t.h2,{id:"retrieving-the-templates",children:"Retrieving the Templates"}),"\n",(0,r.jsxs)(t.p,{children:["In the ",(0,r.jsx)(t.strong,{children:"TableView.GridElementTemplates.xaml"})," file, locate the ",(0,r.jsx)(t.strong,{children:"RowSelector"}),' templates by searching for "',(0,r.jsx)(t.strong,{children:"TEMPLATE: RowSelector"}),'" (remember the naming conventions?). You will notice that there are already 2 templates for the ',(0,r.jsx)(t.strong,{children:"RowSelector"}),", so copy both and place them in the templates section of the ",(0,r.jsx)(t.strong,{children:"TableView.Office2007Tutorial.xaml"})," file. Next, locate the ",(0,r.jsx)(t.strong,{children:"ColumnManagerCell"}),' template and copy it over to the custom-theme project. Search for "',(0,r.jsx)(t.strong,{children:"TEMPLATE: ColumnManagerCell"}),'" to locate it, copy it, and add it to the same location as the ',(0,r.jsx)(t.strong,{children:"RowSelector"})," templates."]}),"\n",(0,r.jsxs)(t.p,{children:['The next step is to change the name of the namespace mapping from "',(0,r.jsx)(t.strong,{children:"markup"}),'" and "',(0,r.jsx)(t.strong,{children:"local"}),'" to "',(0,r.jsx)(t.strong,{children:"xcdg"}),'" so that the elements and their members can be accessed from the custom-theme project. Make sure that you only replace the namespaces in the templates imported from the ',(0,r.jsx)(t.strong,{children:"TableView.GridElementTemplates.xaml"})," file."]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:['"',(0,r.jsx)(t.strong,{children:"local"}),'" is used by default for your custom-theme\'s xmlns attribute. Make sure that you do not replace it with "',(0,r.jsx)(t.strong,{children:"xcdg"}),'".']})}),"\n",(0,r.jsx)(t.h2,{id:"templating-elements",children:"Templating Elements"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["The first element for which we will be providing a template for is the ",(0,r.jsx)(t.strong,{children:"RowSelector"}),' element. "Why not do a style?" you ask? Good question. The ',(0,r.jsx)(t.strong,{children:"RowSelector"})," template includes the resizer thumb, which allows rows to be resized. A style is pretty much limited to the appearance of an element, and we need to modify the appearance of the separator lines, which will have an impact on the resizer thumb. This creates the need for a template since the visual structure and behavior of the ",(0,r.jsx)(t.strong,{children:"RowSelector"})," element will be modified. Ready? Here we go:"]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Locate the template in the ",(0,r.jsx)(t.strong,{children:"TableView.Office2007Tutorial.xaml"})," file by searching for ",(0,r.jsx)(t.strong,{children:"TEMPLATE: RowSelector"})]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Give the parent visual element a name so we can access it later on. In this case, the first border in the grid (not ",(0,r.jsx)(t.strong,{children:"DataGridControl"}),', the other kind) and we will name it "',(0,r.jsx)(t.strong,{children:"mainBorder"}),'"']}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Add a trigger for ",(0,r.jsx)(t.strong,{children:"IsPressed"})," in the ",(0,r.jsx)(t.strong,{children:"ControlTemplate.Triggers"})," to invert the brush when the row selector is pressed."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Create new separator line by:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"adding a new Border at the bottom of the grid;"}),"\n",(0,r.jsx)(t.li,{children:"giving it a width and height of 1 pixel;"}),"\n",(0,r.jsx)(t.li,{children:"a left and right margin of 4 pixels;"}),"\n",(0,r.jsx)(t.li,{children:"and vertically align it to the bottom."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This border will also be added to the second ",(0,r.jsx)(t.strong,{children:"RowSelector"})," template."]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"View the RowSelector template"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <!==**************************\r\n    * TEMPLATE: RowSelector\r\n    ************************** ==>\r\n  <ControlTemplate x:Key="tableViewRowSelectorTemplate"\r\n                    TargetType="xcdg:RowSelector">\r\n      <!== This Grid is used to position the resizer Thumb over the RowSelector ==>\r\n      <Grid>\r\n        <Border x:Name="mainBorder"\r\n                Background="{TemplateBinding Background}"\r\n                BorderBrush="{TemplateBinding BorderBrush}"\r\n                BorderThickness="{TemplateBinding BorderThickness}"\r\n                Padding="{TemplateBinding Padding}">\r\n            <ContentPresenter x:Name="contentPresenter"\r\n                              Content="{TemplateBinding Content}"\r\n                              ContentTemplate="{TemplateBinding ContentTemplate}"\r\n                              ContentTemplateSelector="{TemplateBinding ContentTemplateSelector}"\r\n                              HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"\r\n                              VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />\r\n        </Border>\r\n        <!== Thumb that is used to resize the Row. ==>\r\n        <Thumb x:Name="PART_RowResizerThumb"\r\n                Style="{StaticResource invisibleThumbStyle}"\r\n                VerticalAlignment="Bottom" />\r\n  <Border VerticalAlignment="Bottom"\r\n              Height="1"\r\n              Background="#9AC6FF"\r\n              Margin="4,0,4,0"/> Language Filtered Section XML\r\n      </Grid>\r\n      <ControlTemplate.Triggers>\r\n        <Trigger Property="IsPressed"\r\n                  Value="True">\r\n            <Setter TargetName="mainBorder"\r\n                    Property="Background"\r\n                    Value="{StaticResource rowSelectorPressedBrush}"/>\r\n        </Trigger>\r\n      </ControlTemplate.Triggers>\r\n  </ControlTemplate>\n'})})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Required RowSelector Brushes"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <Color x:Key="mainGradientColor">\r\n      #C4DDFF\r\n  </Color>\r\n  <LinearGradientBrush x:Key="rowSelectorPressedBrush"\r\n                        StartPoint="0,0.5"\r\n                        EndPoint="1,0.5">\r\n      <GradientStop Color="#FFFFFF"\r\n                    Offset="1" />\r\n      <GradientStop Color="{StaticResource mainGradientColor}"\r\n                    Offset="0" />\r\n  </LinearGradientBrush>\n'})})]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:['The next template (don"t worry, it"s the last one) is for the ',(0,r.jsx)(t.strong,{children:"ColumnManagerCell"}),' element. In this template, we will change the background when the mouse is pressed, the separator lines, as well as the glyph that is displayed when the column-manager cell"s associated column is sorted.']}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:'As we did for the second RowSelector template, we want to add a "Pressed" effect on the ColumnManagerCell; therefore, we will have to provide the parent visual element with a different brush when it receives a mouse-down (IsPressed). Let"s break this part into step:'}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Locate the ",(0,r.jsx)(t.strong,{children:"ColumnManagerCell"}),' template by searching for "',(0,r.jsx)(t.strong,{children:"TEMPLATE: ColumnManagerCell"}),'".']}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Give the parent visual element a name so we can access it later on. In this case, the first border in the grid (not ",(0,r.jsx)(t.strong,{children:"DataGridControl"}),') and we will name it "',(0,r.jsx)(t.strong,{children:"mainBorder"}),'"']}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Add a trigger for ",(0,r.jsx)(t.strong,{children:"IsPressed"})," in the ",(0,r.jsx)(t.strong,{children:"ControlTemplate.Triggers"})," to invert the brush when the column-manager cell is pressed."]}),"\n",(0,r.jsx)(t.p,{children:"Now that we have a snazzy new pressed effect, we will change the separator lines. As previously stated, the same RowSelector-style vs. template logic applies here. The new separator lines will be created by a Border that:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"has a right horizontal alignment and a 1-pixel width;"}),"\n",(0,r.jsx)(t.li,{children:"a background set to #9AC6FF;"}),"\n",(0,r.jsx)(t.li,{children:"and the top and bottom margins set to 4 pixels."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This new border is added at the bottom of the ",(0,r.jsx)(t.strong,{children:"Grid"})," (again, not ",(0,r.jsx)(t.strong,{children:"DataGridControl"}),")."]}),"\n",(0,r.jsxs)(t.p,{children:["Lastly, we need to change the color of the glyph that is displayed in a column-manager cell when a column is sorted. In the ",(0,r.jsx)(t.strong,{children:"ColumnManagerCell"})," template there is a ",(0,r.jsx)(t.strong,{children:"ContentPresenter"}),' named "',(0,r.jsx)(t.strong,{children:"sortGlyphPresenter"}),'". Locate it and change its foreground color to #9AC6FF.']}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"View the ColumnManagerCell template"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <!==**************************\r\n    * TEMPLATE: ColumnManagerCell\r\n    ************************** ==>\r\n  <ControlTemplate x:Key="tableViewColumnManagerCellTemplate"\r\n                  TargetType="xcdg:ColumnManagerCell">\r\n    <!== We don\'t use the base Cell Template for the ColumnManagerCell\r\n        because it need more elements to function properly:\r\n        a Thumb named "PART_ColumnResizerThumb" that is used to\r\n        resize the ColumnManagerCells\'s ParentColumn.Width and a glyph\r\n        that represents the Column\'s SortDirection. ==>\r\n    <!== This Grid is used to position the resizer Thumb\r\n        over the ColumnManagerCell ==>\r\n    <Grid>\r\n      <Border x:Name="mainBorder"\r\n              Background="{TemplateBinding Background}"\r\n              BorderBrush="{TemplateBinding BorderBrush}"\r\n              BorderThickness="{TemplateBinding BorderThickness}"\r\n              Padding="{TemplateBinding Padding}">\r\n        <!== This StackPanel is used to lay out the ContentPresenter and the\r\n            Sort Glyph (when present). ==>\r\n        <StackPanel Orientation="Horizontal">\r\n          <!== Same ContentPresenter as in the base Cell Template. ==>\r\n          <ContentPresenter Content="{xcdg:CellContentBinding}"\r\n                ContentTemplate="{TemplateBinding ContentTemplate}"\r\n                ContentTemplateSelector="{TemplateBinding ContentTemplateSelector}"\r\n                HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"\r\n                VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />\r\n          <!== ContentPresenter that is used to display the sort glyph.\r\n              We explicitly set its Content property to Null to prevent\r\n              the XAML parser from implicitely setting it to its\r\n              TemplatedParent\'s Content. ==>\r\n          <ContentPresenter x:Name="sortGlyphPresenter"\r\n                            Content="{x:Null}"\r\n                            ContentTemplate="{x:Null}"\r\n                            TextElement.Foreground="#9AC6FF"/>\r\n        </StackPanel>\r\n      </Border>\r\n      <!== Thumb that is used to resize the Column. ==>\r\n      <Thumb x:Name="PART_ColumnResizerThumb"\r\n            Style="{StaticResource invisibleThumbStyle}"\r\n            HorizontalAlignment="Right" />\r\n        <Border HorizontalAlignment="Right"\r\n                Width="1"\r\n                Background="#9AC6FF"\r\n                Margin="0,4,0,4"/>\r\n    </Grid>\r\n      <ControlTemplate.Triggers>\r\n        <Trigger Property="IsPressed" Value="True">\r\n          <Setter TargetName="mainBorder" Property="Background">\r\n            <Setter.Value>\r\n              <LinearGradientBrush\r\n                        StartPoint="0.5,0"\r\n                        EndPoint="0.5,1">\r\n                <GradientStop Color="#FFFFFF"\r\n                              Offset="1" />\r\n                <GradientStop Color="#C4DDFF"\r\n                              Offset="0" />\r\n              </LinearGradientBrush>\r\n            </Setter.Value>\r\n          </Setter>\r\n        </Trigger>\r\n        <!== The following 2 triggers allow to display the appropriate Sort Glyph\r\n            depending on the ParentColumn\'s SortDirection. ==>\r\n        <DataTrigger Binding="{Binding RelativeSource={RelativeSource Self},\r\n                                      Path=ParentColumn.SortDirection}"\r\n                    Value="Ascending">\r\n          <Setter TargetName="sortGlyphPresenter"\r\n                  Property="ContentPresenter.ContentTemplate"\r\n                  Value="{xcdg:ViewBinding AscendingSortGlyph}"/>\r\n          <Setter TargetName="sortGlyphPresenter"\r\n                  Property="Margin"\r\n                  Value="6,0,0,0"/>\r\n        </DataTrigger>\r\n        <DataTrigger Binding="{Binding RelativeSource={RelativeSource Self},\r\n                                      Path=ParentColumn.SortDirection}"\r\n                    Value="Descending">\r\n          <Setter TargetName="sortGlyphPresenter"\r\n                  Property="ContentPresenter.ContentTemplate"\r\n                  Value="{xcdg:ViewBinding DescendingSortGlyph}"/>\r\n          <Setter TargetName="sortGlyphPresenter"\r\n                  Property="Margin"\r\n                  Value="6,0,0,0"/>\r\n        </DataTrigger>\r\n        <DataTrigger Binding="{Binding RelativeSource={RelativeSource Self},\r\n                                      Path=ParentColumn.HasFixedWidth}"\r\n                    Value="True">\r\n          <Setter TargetName="PART_ColumnResizerThumb"\r\n                  Property="IsEnabled"\r\n                  Value="False"/>\r\n        </DataTrigger>\r\n        <DataTrigger Binding="{Binding RelativeSource={RelativeSource Self},\r\n                                      Path=ParentColumn.Visible}"\r\n                    Value="False">\r\n          <Setter Property="Visibility"\r\n                  Value="Collapsed"/>\r\n        </DataTrigger>\r\n      </ControlTemplate.Triggers>\r\n    </ControlTemplate>\n'})})]}),"\n",(0,r.jsx)(t.p,{children:"You're done. Nothing left to do but use your custom theme!"})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(6540);const i={},l=r.createContext(i);function o(e){const t=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(l.Provider,{value:t},e.children)}}}]);