"use strict";(self.webpackChunkxceed_doc_ui=self.webpackChunkxceed_doc_ui||[]).push([[7252],{8561:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var r=n(4848),i=n(8453);const a={},o="UI Virtualization",l={id:"fundamentals/ui-virtualization",title:"UI Virtualization",description:"UI Virtualization means that the visual representation - the actual control representing the data - is deferred until the item is visible. In other words, only the visible data has a control associated to it. The rationale behind this is to improve performance, as maintaining actual controls is costly in WPF.",source:"@site/datagrid/fundamentals/ui-virtualization.md",sourceDirName:"fundamentals",slug:"/fundamentals/ui-virtualization",permalink:"/xceed-doc-ui/datagrid/fundamentals/ui-virtualization",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebardatagrid",previous:{title:"UI Automation and Testing",permalink:"/xceed-doc-ui/datagrid/fundamentals/automation-testing"},next:{title:"Unbound Columns",permalink:"/xceed-doc-ui/datagrid/fundamentals/unbound-columns"}},s={},d=[{value:"Row Virtualization",id:"row-virtualization",level:2},{value:"Cell Virtualization",id:"cell-virtualization",level:2},{value:"Cells Property",id:"cells-property",level:2},{value:"Customizing a specific cell",id:"customizing-a-specific-cell",level:2},{value:"Examples",id:"examples",level:2}];function c(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"ui-virtualization",children:"UI Virtualization"})}),"\n",(0,r.jsx)(t.p,{children:"UI Virtualization means that the visual representation - the actual control representing the data - is deferred until the item is visible. In other words, only the visible data has a control associated to it. The rationale behind this is to improve performance, as maintaining actual controls is costly in WPF."}),"\n",(0,r.jsx)(t.p,{children:"By default, the DataGrid uses UI Virtualization. That is, it only generates rows and cells for data items that are visible in the viewport of the DataGrid (with some exceptions as stated below). It virtualizes rows in all views, and it virtualizes cells in Table Views only."}),"\n",(0,r.jsx)(t.p,{children:"It is important to note that by default, the DataGrid will take all the room that it requires; therefore, if it is not given a size constraint, such as when it is placed in a StackPanel, and a large amount of data items are present, UI virtualization will be lost\u2014resulting in a significant loss in performance. To preserve virtualization when a grid is in a StackPanel, the MaxWidth and MaxHeight properties (or Width and Height) must be used to constrain the grid. As an alternative, a DockPanel or Grid can be used as both impose size constraints on their child elements."}),"\n",(0,r.jsx)(t.h2,{id:"row-virtualization",children:"Row Virtualization"}),"\n",(0,r.jsx)(t.p,{children:"As there is no Rows property on the DataGridControl, a row can only be retrieved by using the DataGridControl.GetContainerFromItem or DataGridContext.GetContainerFromItem method for a specific data source item. However, if the item is not actually displayed in the DataGrid\u2019s viewport, no row will be associated with it, and the method will return null. Hence, references to rows, or one of their cells, should not be kept. Moreover, the DataGrid uses a recycling mechanism, in which the same instance of a row is reused to display a different item when there is a change in the viewport, for instance through a change to sorting. Hence keeping a reference to a row can result in a row being associated to an item different from the one from which it was originally obtained."}),"\n",(0,r.jsx)(t.h2,{id:"cell-virtualization",children:"Cell Virtualization"}),"\n",(0,r.jsx)(t.p,{children:"At the cell level, what follows only apply to Table Views. Cells are NOT virtualized in other views. The default behavior of the DataGrid is the same as it is at the row level. That is, cells only exist for columns that are in the viewport. The DataGrid also uses a recycling mechanism for cells, that is, the same cell instances are reused to display different columns when there is a change in the viewport, for instance when the DataGrid is horizontally scrolled."}),"\n",(0,r.jsx)(t.p,{children:"However, there are 2 other modes to cell virtualization (called column virtualization in fact) that can be used with the DataGrid, which modify this behavior. The TableView.ColumnVirtualizationMode property determines which mode is used. It can be set to None, Recycling, Virtualizing."}),"\n",(0,r.jsx)(t.p,{children:"The Recycling mode is the default behavior, as just explained. In None mode, there is no recycling nor virtualization. All cells are created for all columns, present in the viewport or not \u2013 of course only for existing rows. In Virtualizing mode, there is no recycling, that is each column has its own cell assigned to it, but cells are still virtualized, in that cells are put in a non-available state as if they had not been created (see the Column Virtualization topic on this page for more details)."}),"\n",(0,r.jsx)(t.h2,{id:"cells-property",children:"Cells Property"}),"\n",(0,r.jsx)(t.p,{children:"The major difference at the cell level is that, contrary to having no Rows property, there is a Cells property, and it is found on the Row class. Thus a cell can be obtained for a specific column by using the indexer on this property, even if the column is not in view. However, though all operations are supported, except the CopyTo method which will raise an exception, they are all not recommended, except the Contains method, depending on the row type."}),"\n",(0,r.jsxs)(t.p,{children:["For ",(0,r.jsx)(t.code,{children:"DataRow"}),", ",(0,r.jsx)(t.code,{children:"InsertionRow"}),", ",(0,r.jsx)(t.code,{children:"ColumnManagerRow"}),", and ",(0,r.jsx)(t.code,{children:"MergedColumnManagerRow"})," types, ",(0,r.jsx)(t.code,{children:"Cells"})," are automatically generated and managed, and the resulting collection should never be modified or accessed in any way. Hence, the following operation should never be used under any circumstances:"]}),"\n",(0,r.jsx)(t.p,{children:"Add\r\nInsert\r\nRemove\r\nRemoveAt\r\nClear"}),"\n",(0,r.jsx)(t.p,{children:"The following operations should be used with extreme caution, and should not be required in any scenario. Alternative ways are available (see examples)."}),"\n",(0,r.jsx)(t.p,{children:"[ int index ]\r\nCount\r\nIndexOf"}),"\n",(0,r.jsx)(t.p,{children:"Though these operations will return valid values, be aware of the following. Count will always return the count of columns on the grid, whether some are hidden or not, independent of how many cells are actually present in the collection. IndexOf will return the index of the corresponding parent column in its original position, independent of its visible status. So if a column has been moved, IndexOf will not reflect this. Hence, querying a cell with the int indexer will do exactly the same, that is, return the cell at the corresponding parent column original position."}),"\n",(0,r.jsx)(t.p,{children:"The rationale behind returning these values is that because of virtualization and recycling, there is no relationship between the position of a cell within the CellCollection and where the internal mechanism will actually position the cell in the viewport. For instance, a cell may be used to display the value of a parent column that is the 3rd one in the viewport, but its position in the CellCollection may be the first one."}),"\n",(0,r.jsx)(t.p,{children:"There are two other indexers:"}),"\n",(0,r.jsx)(t.p,{children:"[ ColumnBase column ]\r\n[ string fieldName ]"}),"\n",(0,r.jsx)(t.p,{children:"These will return the cell associated with the column itself or its FieldName. However, if querying a cell that is not in view, this will result in an unwanted effect on virtualization. For instance, in Recycling mode, querying a cell of a column which is not in view will prompt the creation of a new cell, which will be added to the CellCollection, and which will be present from then on. This defeats the purpose of this mode of virtualization, which is to create as few cells as possible."}),"\n",(0,r.jsx)(t.p,{children:"This is why iterating through Cells with a foreach statement is supported but definitely not recommended. The result will be that all cells will be generated, in essence disabling cell virtualization."}),"\n",(0,r.jsxs)(t.p,{children:["What precedes apply to the other row types, that is, ",(0,r.jsx)(t.code,{children:"StatRow"}),", ",(0,r.jsx)(t.code,{children:"FilterRow"}),", and ",(0,r.jsx)(t.code,{children:"FlexibleRow"}),", except for what follows."]}),"\n",(0,r.jsxs)(t.p,{children:["For StatRow and ",(0,r.jsx)(t.code,{children:"FlexibleRow"}),", cells need to be added manually (in code behind or in xaml) for them to display a content. If not, cells will be automatically added and handled with no content. The only exception to this is the ",(0,r.jsx)(t.code,{children:"FilterRow"}),". It\u2019s not required to manually provide cells to display a content, but if customisation is required (like a different CellContentTemplate), then corresponding cells must also be provided manually. The recommended operations to accomplish this are Add and Remove. There is no need to provide an index, as it is the FieldName that will correctly associate a cell to a column. The internal virtualization mechanism will properly maintain and use it."]}),"\n",(0,r.jsx)(t.p,{children:"As for the column and fieldName indexers, as long as they are used to query cells that have been manually added, it will work fine, as these cells are not recycled or virtualized, hence always present in the CellCollection. If they are used to query cells that have not been manually provided, then the result will be as mentioned above, defeating the purpose of virtualization. The only exception here is if the goal is to add a new cell for a column so it can display a content, then it can be used, as it will have the same result as using the Add method with a newly created cell."}),"\n",(0,r.jsx)(t.admonition,{type:"caution",children:(0,r.jsx)(t.p,{children:"Conclusion: in essence, the Cells property is present on Row only so cells can be added or removed from StatRow, FilterRow, and FlexibleRow types.  Is should not be used for any other purpose."})}),"\n",(0,r.jsx)(t.h2,{id:"customizing-a-specific-cell",children:"Customizing a specific cell"}),"\n",(0,r.jsx)(t.p,{children:"As a result, setting any property on a cell (or a row for that matter) should be done through templates, styles, and triggers (see example 1 to 5).  If the content of a cell needs to be access, unless it is the one being edited, it is should be accessed through the corresponding property on the corresponding data source item (see example 6)."}),"\n",(0,r.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(t.p,{children:"All examples in this topic assume that the grid is bound to the Orders table of the Northwind database, unless stated otherwise."}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Example 1: Providing a cell-content template"}),(0,r.jsxs)(t.p,{children:["The following example demonstrates how to provide a new CellContentTemplate, using property element syntax, for a boolean column that displays a check mark when the cell's value is ",(0,r.jsx)(t.strong,{children:"true"}),', and an "x" when it is ',(0,r.jsx)(t.strong,{children:"false"}),"."]}),(0,r.jsx)(t.p,{children:"This example assumes that the grid is bound to the Products table of the Northwind database."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'<Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n  <Grid.Resources>\r\n    <xcdg:DataGridCollectionViewSource x:Key="cvs_products"\r\n                                    Source="{Binding Source={x:Static Application.Current},\r\n                                                      Path=Products}"/>\r\n  </Grid.Resources>\r\n  <xcdg:DataGridControl x:Name="ProductsGrid"\r\n                        ItemsSource="{Binding Source={StaticResource cvs_products}}">\r\n      <xcdg:DataGridControl.Columns>\r\n        <xcdg:Column FieldName="Discontinued">\r\n          <xcdg:Column.CellContentTemplate>\r\n              <DataTemplate>\r\n                <Image x:Name="img" Source="D:\\true.png" Stretch="None" />\r\n                    <DataTemplate.Triggers>\r\n                      <DataTrigger Binding="{Binding}" Value="False">\r\n                        <Setter TargetName="img" Property="Source" Value="D:\\false.png" />\r\n                      </DataTrigger>\r\n                    </DataTemplate.Triggers>\r\n              </DataTemplate>\r\n          </xcdg:Column.CellContentTemplate>\r\n        </xcdg:Column>\r\n      </xcdg:DataGridControl.Columns>\r\n  </xcdg:DataGridControl>\r\n</Grid>\n'})})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Example 2: Styling data cells"}),(0,r.jsx)(t.p,{children:"The following example demonstrates how to change the foreground and background of the current cell."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n    <Grid.Resources>\r\n      <Style TargetType="{x:Type xcdg:DataCell}">\r\n        <Setter Property="CurrentForeground">\r\n          <Setter.Value>\r\n            <SolidColorBrush Color="Yellow"/>\r\n          </Setter.Value>\r\n          </Setter>\r\n            <Setter Property="CurrentBackground">\r\n              <Setter.Value>\r\n            <SolidColorBrush Color="Orange"/>\r\n          </Setter.Value>\r\n        </Setter>\r\n      </Style>\r\n      <xcdg:DataGridCollectionViewSource x:Key="cvs_orders"\r\n                                      Source="{Binding Source={x:Static Application.Current},\r\n                                                        Path=Orders}"/>\r\n    </Grid.Resources>\r\n    <xcdg:DataGridControl x:Name="OrdersGrid"\r\n                          ItemsSource="{Binding Source={StaticResource cvs_orders}}"/>\r\n  </Grid>\n'})})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Example 3: Styling data cells through triggers"}),(0,r.jsx)(t.p,{children:"The following example demonstrates how to change the background of all cells of a specific column."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n    <Grid.Resources>\r\n      <Style TargetType="{x:Type xcdg:DataCell }">\r\n        <Style.Triggers>\r\n          <DataTrigger Binding="{Binding RelativeSource={RelativeSource Self}, Path=FieldName}"\r\n                      Value="OrderID">\r\n            <Setter Property="Background"\r\n                    Value="DodgerBlue" />\r\n          </DataTrigger>\r\n        </Style.Triggers>\r\n      </Style>\r\n      <xcdg:DataGridCollectionViewSource x:Key="cvs_orders"\r\n                                        Source="{Binding Source={x:Static Application.Current}, Path=Orders}"/>\r\n    </Grid.Resources>\r\n    <xcdg:DataGridControl x:Name="OrdersGrid"\r\n                          ItemsSource="{Binding Source={StaticResource cvs_orders}}"/>\r\n  </Grid>\n'})}),(0,r.jsx)(t.p,{children:"The following example demonstrates how to change the background of a cell with a specific value."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-XML",children:'<Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n  <Grid.Resources>\r\n    <Style TargetType="{x:Type xcdg:DataCell }">\r\n      <Style.Triggers>\r\n        <MultiDataTrigger>\r\n          <MultiDataTrigger.Conditions>\r\n            <Condition Binding="{Binding RelativeSource={RelativeSource Self}, Path=ParentColumn.FieldName}"\r\n                      Value="CustomerID" />\r\n            <Condition Binding="{Binding Path=CustomerID}"\r\n                      Value="VINET" />\r\n          </MultiDataTrigger.Conditions>\r\n          <Setter Property="Background"\r\n                  Value="DarkOrange" />\r\n        </MultiDataTrigger>\r\n      </Style.Triggers>\r\n    </Style>\r\n    <xcdg:DataGridCollectionViewSource x:Key="cvs_orders"\r\n                                      Source="{Binding Source={x:Static Application.Current}, Path=Orders}"/>\r\n  </Grid.Resources>\r\n  <xcdg:DataGridControl x:Name="OrdersGrid"\r\n                        ItemsSource="{Binding Source={StaticResource cvs_orders}}"/>\r\n</Grid>\n'})}),(0,r.jsx)(t.p,{children:"The following example demonstrates how to change the background of a cell that has been edited but which value has not yet been committed to the data source item.  Note that the Cell.IsDirty property will be true only until the row is committed if DataGridControl.UpdateSourceTigger is set to RowEndingEdit \u2013 which is the default value of this property."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-XML",children:'<Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n  <Grid.Resources>\r\n    <Style TargetType="{x:Type xcdg:DataCell }">\r\n      <Style.Triggers>\r\n        <DataTrigger Binding="{Binding RelativeSource={RelativeSource Self}, Path=IsDirty}"\r\n                    Value="True">\r\n          <Setter Property="Background"\r\n                  Value="DeepSkyBlue" />\r\n        </DataTrigger>\r\n      </Style.Triggers>\r\n    </Style>\r\n    <xcdg:DataGridCollectionViewSource x:Key="cvs_orders"\r\n                                      Source="{Binding Source={x:Static Application.Current}, Path=Orders}"/>\r\n  </Grid.Resources>\r\n  <xcdg:DataGridControl x:Name="OrdersGrid"\r\n                        ItemsSource="{Binding Source={StaticResource cvs_orders}}"/>\r\n</Grid>\n'})})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Example 4: Retrieving the value of the content of a cell through its data source item"}),(0,r.jsx)(t.p,{children:"The following example demonstrates how to show a tooltip on a DataRow which displays the value corresponding to the content of a cell of a hidden column."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <Grid xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid">\r\n    <Grid.Resources>\r\n      <Style TargetType="{x:Type xcdg:DataRow}">\r\n        <EventSetter  Event="MouseEnter"\r\n                      Handler="OnDataRowMouseEnter" />\r\n      </Style>\r\n      <xcdg:DataGridCollectionViewSource x:Key="cvs_orders"\r\n                                        Source="{Binding Source={x:Static Application.Current}, Path=Orders}"/>\r\n    </Grid.Resources>\r\n    <xcdg:DataGridControl x:Name="OrdersGrid"\r\n                          ItemsSource="{Binding Source={StaticResource cvs_orders}}" >\r\n      <xcdg:DataGridControl.Columns>\r\n        <xcdg:Column FieldName="OrderID"\r\n                    Visible="False" />\r\n      </xcdg:DataGridControl.Columns>\r\n    </xcdg:DataGridControl>\r\n  </Grid>\n'})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'  private void OnDataRowMouseEnter( object sender, MouseEventArgs e )\r\n  {\r\n    var dataRow = sender as Xceed.Wpf.DataGrid.DataRow;\r\n    if( dataRow == null )\r\n      return;\r\n    var dataRowView = dataRow.DataContext as System.Data.DataRowView;\r\n    if( dataRowView == null )\r\n      return;\r\n    dataRow.ToolTip = dataRowView.Row[ "OrderID" ].ToString();\r\n  }\n'})})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var r=n(6540);const i={},a=r.createContext(i);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);