"use strict";(self.webpackChunkxceed_doc_ui=self.webpackChunkxceed_doc_ui||[]).push([[9210],{6959:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>n,default:()=>h,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var o=i(4848),r=i(8453);const a={},n="DataGridCollectionView Class",d={id:"object-model-view/datagrid-collectionview-class/datagrid-collectionview-class",title:"DataGridCollectionView Class",description:"The DataGridCollectionView class allows any collection that implements the IEnumerable interface to be grouped, sorted, or filtered. Unlike the BindingListCollectionView class, the DataGridCollectionView class will never touch the underlying data source, meaning that the original sorting and filtering present in the data source will not be modified. The underlying data source to which the DataGridCollectionView is bound can be retrieved through the SourceCollection property.",source:"@site/datagrid/object-model-view/datagrid-collectionview-class/datagrid-collectionview-class.md",sourceDirName:"object-model-view/datagrid-collectionview-class",slug:"/object-model-view/datagrid-collectionview-class/",permalink:"/xceed-doc-ui/datagrid/object-model-view/datagrid-collectionview-class/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebardatagrid",previous:{title:"Row Class",permalink:"/xceed-doc-ui/datagrid/object-model-view/row-class"},next:{title:"DataGridDetailDescription Class",permalink:"/xceed-doc-ui/datagrid/object-model-view/datagrid-collectionview-class/datagrid-detaildescription"}},s={},l=[{value:"Grouping, Sorting, and Filtering",id:"grouping-sorting-and-filtering",level:2},{value:"Detail Relations (Hierarchical Master/Detail)",id:"detail-relations-hierarchical-masterdetail",level:2},{value:"Inserting and Editing Data Items",id:"inserting-and-editing-data-items",level:2},{value:"DataGridCollectionViewSource Class",id:"datagridcollectionviewsource-class",level:2},{value:"Data Virtualization",id:"data-virtualization",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"datagridcollectionview-class",children:"DataGridCollectionView Class"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," class allows any collection that implements the IEnumerable interface to be grouped, sorted, or filtered. Unlike the ",(0,o.jsx)(t.code,{children:"BindingListCollectionView"})," class, the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," class will never touch the underlying data source, meaning that the original sorting and filtering present in the data source will not be modified. The underlying data source to which the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," is bound can be retrieved through the ",(0,o.jsx)(t.code,{children:"SourceCollection"})," property."]}),"\n",(0,o.jsxs)(t.p,{children:["By default, a DataGridItemProperty will be created for each property in the underlying data source and can be retrieved through the ",(0,o.jsx)(t.code,{children:"ItemProperties"})," property of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," (you can consider these items to be the columns that will end up in a grid). Each item-property object represents the characteristics of a property for an item in the DataGridCollectionView, including the ",(0,o.jsx)(t.code,{children:"DataType"}),", ",(0,o.jsx)(t.code,{children:"Name"}),", ",(0,o.jsx)(t.code,{children:"PropertyDescriptor"}),", ",(0,o.jsx)(t.code,{children:"Title"}),", and ",(0,o.jsx)(t.code,{children:"ValuePath"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["When you set the GroupSortStatResultPropertyName property to a valid ",(0,o.jsx)(t.code,{children:"StatFunction.ResultPropertyName"})," defined in ",(0,o.jsx)(t.code,{children:"DataGridCollectionView.StatFunctions"}),", sorting by the ",(0,o.jsx)(t.code,{children:"DataGridItemProperty"})," having a ",(0,o.jsx)(t.code,{children:"StatResultPropertyName"})," will also sort the group by the stat result of that name."]}),"\n",(0,o.jsxs)(t.p,{children:["When you set the ",(0,o.jsx)(t.code,{children:"GroupSortStatResultComparer"})," property, the groups are ordered based on whether GroupSortStatResultPropertyName is also set; the passed IComparer will receive the stat result as values. If you do not pass any comparer, the default sort comparer for the returning type of the stat result will be used.\r\nMultiple ",(0,o.jsx)(t.code,{children:"DataGridItemProperty"})," sorting is also supported. For example, if property A and B have a GroupSortStatResultPropertyName that points to a sum, we are sorted by A then by B. When sum of A is equal, the sum of B will be used to determine the group order."]}),"\n",(0,o.jsx)(t.p,{children:"In order to avoid performance degradation, when modifying a cell value, only the group affected by that cell value modification is reordered, so there should not be any significant performance degradation when using this property."}),"\n",(0,o.jsxs)(t.p,{children:["Automatic creation of item properties can be disabled by setting the ",(0,o.jsx)(t.code,{children:"AutoCreateItemProperties"})," property of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," to false (by default, true) or by specifying so when creating an instance of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," Contains method determines whether an item exists in the current view, while the ",(0,o.jsx)(t.code,{children:"GetItemAt"})," and ",(0,o.jsx)(t.code,{children:"IndexOf"})," methods can be used to retrieve an item at a specific index or retrieve its index, respectively. The number of items contained in a ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," can be determined through the Count property. In the case where no items are displayed in the view, the ",(0,o.jsx)(t.code,{children:"Count"})," property will return 0 and the IsEmpty property will return true."]}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["Programmatically, when the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," is bound to a data source, the ",(0,o.jsx)(t.code,{children:"ItemProperties.Clear"})," method must be called prior to adding ",(0,o.jsx)(t.code,{children:"DataGridItemProperty"})," objects to the ItemProperties collection to remove items that were automatically added when the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," was instantiated."]})}),"\n",(0,o.jsxs)(t.p,{children:['Unbound data can be "appended" to a data item through the use of unbound item properties, which are represented by the ',(0,o.jsx)(t.code,{children:"DataGridUnboundItemProperty"})," class. Unlike unbound columns, which can be used to display non-data related information such as a label or controls that allow some sort of action to be carried out, unbound item properties can be used to provide additional data, such as calculated columns."]}),"\n",(0,o.jsx)(t.h2,{id:"grouping-sorting-and-filtering",children:"Grouping, Sorting, and Filtering"}),"\n",(0,o.jsxs)(t.p,{children:["Data items contained in the view can be grouped using either the default ",(0,o.jsx)(t.code,{children:"PropertyGroupDescription"})," or the ",(0,o.jsx)(t.code,{children:"DataGridGroupDescription"})," (recommended) and adding them to the ",(0,o.jsx)(t.code,{children:"GroupDescriptions"})," property. The final, runtime groups can be retrieved through the ",(0,o.jsx)(t.code,{children:"Groups"})," property. Data items can also be sorted by adding the standard ",(0,o.jsx)(t.code,{children:"SortDescription"})," structures to the ",(0,o.jsx)(t.code,{children:"SortDescriptions"})," property. In addition to the default type-based sorting, custom sorting can also be applied by providing an ",(0,o.jsx)(t.code,{children:"IComparer"})," to the ",(0,o.jsx)(t.code,{children:"SortComparer"})," property of one or more item properties defined in the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," to which a grid is bound."]}),"\n",(0,o.jsx)(t.h2,{id:"detail-relations-hierarchical-masterdetail",children:"Detail Relations (Hierarchical Master/Detail)"}),"\n",(0,o.jsx)(t.p,{children:"If the data source to which a DataGridCollectionView is bound contains hierarchical detail relations, the content of those relations will be displayed as the details of data items in a grid or in another detail. Relations are represented by DataGridDetailDesciption objects and will automatically be created for:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["every ",(0,o.jsx)(t.code,{children:"DataRelation"})," in a ",(0,o.jsx)(t.code,{children:"DataTable"})," (",(0,o.jsx)(t.code,{children:"DataRelationDetailDescription"}),")"]}),"\n",(0,o.jsxs)(t.li,{children:["data items that implement the ",(0,o.jsx)(t.code,{children:"IEnumerable"})," interface (",(0,o.jsx)(t.code,{children:"EnumerableDetailDescription"}),")"]}),"\n",(0,o.jsxs)(t.li,{children:["data items that implement the ",(0,o.jsx)(t.code,{children:"IListSource"})," interface (",(0,o.jsx)(t.code,{children:"ListSourceDetailDescription"}),")"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Automatic creation of detail descriptions can be disabled by setting the ",(0,o.jsx)(t.code,{children:"AutoCreateDetailDescriptions"})," property of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," to false (by default, ",(0,o.jsx)(t.strong,{children:"true"}),") or by specifying so when creating an instance of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["In order for the details of a data item to be displayed (and created), the parent grid or detail's ",(0,o.jsx)(t.code,{children:"AutoCreateDetailConfigurations"})," property must be set to true (by default, false at the grid level and true for detail configurations)."]}),"\n",(0,o.jsx)(t.h2,{id:"inserting-and-editing-data-items",children:"Inserting and Editing Data Items"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," and ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," classes expose events (see Table 1 in ",(0,o.jsx)(t.a,{href:"/datagrid/fundamentals/providing-inserting-remove/inserting-data",children:"Inserting Data"}),") that are triggered during key stages of inserting a new item into an underlying data source. These events provide full control over the insertion process and make it possible to insert items into a source that does not implement the IBindingList interface."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," also exposes the ",(0,o.jsx)(t.code,{children:"EditItem"}),", ",(0,o.jsx)(t.code,{children:"CommitEdit"}),", and ",(0,o.jsx)(t.code,{children:"CancelEdit"})," methods to allow items in the underlying data source to be edited directly."]}),"\n",(0,o.jsx)(t.h2,{id:"datagridcollectionviewsource-class",children:"DataGridCollectionViewSource Class"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," class represents the XAML proxy of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," class. The ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," class is not a view but rather the XAML representation of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," class."]}),"\n",(0,o.jsxs)(t.p,{children:["Most properties and events exposed by the ",(0,o.jsx)(t.code,{children:"DataGridCollectionView"})," class are also exposed by the ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," class."]}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["Most of the XAML examples demonstrated throughout this documentation make use of the ",(0,o.jsx)(t.code,{children:"DataGridCollectionViewSource"})," class to provide data to a grid."]})}),"\n",(0,o.jsx)(t.h2,{id:"data-virtualization",children:"Data Virtualization"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"DataGridVirtualizingCollectionView"})," class and its XAML proxy, the ",(0,o.jsx)(t.code,{children:"DataGridVirtualizingCollectionViewSource"}),' class, provide support for data virtualization. Also known as "virtual mode" or "lazy loading", data virtualization provides smart deferred querying of data, support for asynchronous data fetching, preemptive loading, and query abort notifications to ensure a smooth and seamless experience that leaves applications responsive and prevents needless queries to data servers.']})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>n,x:()=>d});var o=i(6540);const r={},a=o.createContext(r);function n(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);